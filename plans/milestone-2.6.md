# Milestone 2.6: Compiler & Code Generation

**Duration:** 3-4 weeks
**Status:** ðŸ”œ Not Started
**Dependencies:**
- Milestone 2.3 (Parser) âœ… Complete
- Milestone 2.4 (Type System) âœ… Complete
- Milestone 2.5 (Type Checker) âœ… Complete
**Next Milestone:** 3.1 (Standard Library Foundation)

---

## Table of Contents

1. [Overview](#overview)
2. [Goals](#goals)
3. [Non-Goals](#non-goals)
4. [Architecture](#architecture)
5. [Phase 1: Basic Code Generation](#phase-1-basic-code-generation-week-1)
6. [Phase 2: Control Flow & Functions](#phase-2-control-flow--functions-week-2)
7. [Phase 3: Classes & Objects](#phase-3-classes--objects-week-3)
8. [Phase 4: Advanced Features](#phase-4-advanced-features--optimization-week-4)
9. [Testing Strategy](#testing-strategy)
10. [Success Criteria](#success-criteria)

---

## Overview

Implement a compiler that transforms type-checked Raya AST into bytecode for the Raya VM. The compiler performs:
- Code generation for all language constructs
- Generic monomorphization (like Rust/C++)
- Optimization passes
- Bytecode emission

### What is Code Generation?

Code generation (codegen) translates high-level language constructs into low-level bytecode instructions that the VM can execute.

**Input:** Type-checked AST from type checker (Milestone 2.5)
```rust
VariableDecl {
    name: "x",
    type: TypeId(Number),
    initializer: BinaryExpression {
        left: IntLiteral(10),
        op: Plus,
        right: IntLiteral(32),
    }
}
```

**Output:** Bytecode module
```
ConstI32 10      // Push 10
ConstI32 32      // Push 32
Iadd             // Add them
StoreLocal 0     // Store in local 0
```

### Key Features

- **Typed opcodes**: Use `Iadd`/`Fadd`/`Nadd` based on static types
- **Monomorphization**: Specialize generic code per type instantiation
- **Optimization**: Constant folding, dead code elimination
- **Async compilation**: Convert `async` functions to Task spawning

---

## Goals

### Primary Goals

1. **Complete Language Coverage**: Generate bytecode for all Raya constructs
2. **Type-Driven Optimization**: Use type information for efficient code
3. **Monomorphization**: Specialize generic functions/classes
4. **Correct Semantics**: Match language specification exactly
5. **Async/Await**: Compile async functions to SPAWN/AWAIT opcodes
6. **Error Handling**: Try/catch â†’ exception handling opcodes

### Secondary Goals

1. **Optimization Passes**: Constant folding, dead code elimination
2. **Debug Information**: Source maps for stack traces
3. **Bytecode Verification**: Validate generated bytecode
4. **Module Linking**: Handle imports/exports

---

## Non-Goals

1. **JIT Compilation**: Runtime code generation (future milestone)
2. **Incremental Compilation**: Recompile only changed modules
3. **Advanced Optimizations**: Inlining, loop unrolling (future)
4. **Reflection Emission**: Runtime type information (separate flag)

---

## Architecture

### Compiler Structure

```
Compiler
â”œâ”€â”€ codegen: CodeGenerator        // Main code generator
â”œâ”€â”€ monomorph: Monomorphizer      // Generic specialization
â”œâ”€â”€ optimizer: Optimizer          // Bytecode optimization
â”œâ”€â”€ module_builder: ModuleBuilder // Bytecode module construction
â””â”€â”€ symbol_map: SymbolMap         // Track local/global indices
```

### Module Organization

```
crates/raya-compiler/src/
â”œâ”€â”€ lib.rs                 // Public API
â”œâ”€â”€ codegen/
â”‚   â”œâ”€â”€ mod.rs            // CodeGenerator struct
â”‚   â”œâ”€â”€ expr.rs           // Expression codegen
â”‚   â”œâ”€â”€ stmt.rs           // Statement codegen
â”‚   â”œâ”€â”€ function.rs       // Function codegen
â”‚   â”œâ”€â”€ class.rs          // Class codegen
â”‚   â”œâ”€â”€ pattern.rs        // Pattern matching codegen
â”‚   â””â”€â”€ async.rs          // Async/await codegen
â”œâ”€â”€ monomorph/
â”‚   â”œâ”€â”€ mod.rs            // Monomorphizer
â”‚   â”œâ”€â”€ instantiate.rs    // Generic instantiation
â”‚   â””â”€â”€ cache.rs          // Instantiation cache
â”œâ”€â”€ optimize/
â”‚   â”œâ”€â”€ mod.rs            // Optimization passes
â”‚   â”œâ”€â”€ constant_fold.rs  // Constant folding
â”‚   â”œâ”€â”€ dce.rs            // Dead code elimination
â”‚   â””â”€â”€ peephole.rs       // Peephole optimizations
â”œâ”€â”€ module_builder.rs     // Bytecode module builder
â”œâ”€â”€ symbol_map.rs         // Symbol index tracking
â””â”€â”€ error.rs              // Compilation errors

tests/
â”œâ”€â”€ codegen_tests.rs      // Code generation tests
â”œâ”€â”€ monomorph_tests.rs    // Monomorphization tests
â”œâ”€â”€ optimize_tests.rs     // Optimization tests
â””â”€â”€ integration_tests.rs  // End-to-end compilation
```

### Compilation Pipeline

```
Type-Checked AST
    â†“
Monomorphization (generics â†’ concrete types)
    â†“
Code Generation (AST â†’ bytecode)
    â†“
Optimization (bytecode â†’ optimized bytecode)
    â†“
Module Building (bytecode â†’ Module)
    â†“
Bytecode Verification
    â†“
.rbin file (serialized Module)
```

---

## Phase 1: Basic Code Generation (Week 1)

**Duration:** 5-7 days
**Goal:** Generate bytecode for expressions, variables, and basic statements

### Task 1.1: Compiler Infrastructure

**New crate:** `crates/raya-compiler/`

```toml
# Cargo.toml
[package]
name = "raya-compiler"
version = "0.1.0"
edition = "2021"

[dependencies]
raya-bytecode = { path = "../raya-bytecode" }
raya-parser = { path = "../raya-parser" }
raya-types = { path = "../raya-types" }
raya-checker = { path = "../raya-checker" }
rustc-hash = "2.0"
thiserror = "2.0"
```

**Core structures:**

```rust
// crates/raya-compiler/src/lib.rs
pub struct Compiler {
    type_ctx: TypeContext,
    codegen: CodeGenerator,
    monomorph: Monomorphizer,
    optimizer: Optimizer,
}

impl Compiler {
    pub fn compile(module: &Module, symbols: &SymbolTable) -> Result<BytecodeModule, CompileError>;
}

// crates/raya-compiler/src/codegen/mod.rs
pub struct CodeGenerator<'a> {
    type_ctx: &'a TypeContext,
    symbols: &'a SymbolTable,
    module_builder: ModuleBuilder,
    current_function: Option<FunctionBuilder>,
    local_map: FxHashMap<String, u16>,
}
```

### Task 1.2: Expression Code Generation

**File:** `crates/raya-compiler/src/codegen/expr.rs`

**Expressions to compile:**

1. **Literals:**
   - Integers â†’ `ConstI32`
   - Floats â†’ `ConstF64`
   - Strings â†’ `ConstStr` (string pool)
   - Booleans â†’ `ConstTrue`/`ConstFalse`
   - Null â†’ `ConstNull`

2. **Binary operations:**
   - Use type information to select opcode
   - `number + number` â†’ `Iadd` or `Fadd` based on integer/float
   - `string + string` â†’ `Sadd`
   - Comparison operators â†’ `Ilt`, `Flt`, `Eq`, etc.

3. **Unary operations:**
   - Negation: `-x` â†’ `Ineg` or `Fneg`
   - Logical not: `!x` â†’ `Not`
   - Typeof: `typeof x` â†’ `Typeof`

4. **Variables:**
   - Identifier â†’ `LoadLocal` or `LoadGlobal` (based on scope)

**Type-driven opcode selection:**

```rust
fn compile_binary_add(&mut self, left_ty: TypeId, right_ty: TypeId) {
    match (self.type_ctx.get(left_ty), self.type_ctx.get(right_ty)) {
        (Type::Primitive(Number), Type::Primitive(Number)) => {
            // Check if both are integers or floats
            self.emit(Opcode::Iadd); // or Fadd
        }
        (Type::Primitive(String), Type::Primitive(String)) => {
            self.emit(Opcode::Sadd);
        }
        _ => {
            // Generic number addition
            self.emit(Opcode::Nadd);
        }
    }
}
```

### Task 1.3: Variable Declarations

**Compilation:**
- `let x = 42;` â†’ Allocate local slot, emit initializer, `StoreLocal`
- `const x = "hello";` â†’ Same as `let` (const is compile-time only)
- Track local variable indices in `local_map`

**Example:**
```typescript
let x: number = 10 + 32;
```

**Bytecode:**
```
ConstI32 10
ConstI32 32
Iadd
StoreLocal 0
```

### Task 1.4: Module Builder

**File:** `crates/raya-compiler/src/module_builder.rs`

**Responsibilities:**
- Build `Module` structure from bytecode
- Manage constant pool (strings, numbers)
- Assign function indices
- Track imports/exports

```rust
pub struct ModuleBuilder {
    name: String,
    constants: ConstantPoolBuilder,
    functions: Vec<Function>,
    classes: Vec<ClassDef>,
    imports: Vec<Import>,
    exports: Vec<Export>,
}

impl ModuleBuilder {
    pub fn add_string_constant(&mut self, s: String) -> u32;
    pub fn add_function(&mut self, func: Function) -> u16;
    pub fn build(self) -> Module;
}
```

### Verification (Phase 1)

**Tests:** `crates/raya-compiler/tests/codegen_tests.rs`

```rust
#[test]
fn test_compile_integer_literal() {
    let source = "42";
    let bytecode = compile_expr(source);
    assert_eq!(bytecode, vec![Opcode::ConstI32 as u8, 42, 0, 0, 0]);
}

#[test]
fn test_compile_binary_add() {
    let source = "10 + 32";
    let bytecode = compile_expr(source);
    assert_eq!(bytecode, vec![
        Opcode::ConstI32 as u8, 10, 0, 0, 0,
        Opcode::ConstI32 as u8, 32, 0, 0, 0,
        Opcode::Iadd as u8,
    ]);
}

#[test]
fn test_compile_variable_decl() {
    let source = "let x = 42;";
    let module = compile_module(source);
    // Verify bytecode
}
```

**Success Criteria:**
- âœ… Literals compile correctly
- âœ… Binary/unary expressions compile
- âœ… Variable declarations work
- âœ… Type-driven opcode selection
- âœ… 20+ tests passing

---

## Phase 2: Control Flow & Functions (Week 2)

**Duration:** 5-7 days
**Goal:** Compile control flow statements and function definitions

### Task 2.1: Control Flow Statements

**If statements:**
```typescript
if (condition) {
    thenBranch();
} else {
    elseBranch();
}
```

**Bytecode:**
```
<condition code>
JmpIfFalse else_label
<then branch code>
Jmp end_label
else_label:
<else branch code>
end_label:
```

**Loops:**
- **While:** Loop start, condition, `JmpIfFalse` to end, body, `Jmp` to start
- **For:** Init, loop start, test, `JmpIfFalse` to end, body, update, `Jmp` to start

**Switch statements:**
- Compile to series of equality checks and jumps
- Track case labels for jump targets

### Task 2.2: Function Compilation

**Function declaration:**
```typescript
function add(a: number, b: number): number {
    return a + b;
}
```

**Compilation steps:**
1. Create `Function` struct
2. Allocate parameter slots (locals 0, 1)
3. Compile body
4. Emit `Return` at end
5. Add to module

**Function calls:**
```typescript
let result = add(10, 20);
```

**Bytecode:**
```
ConstI32 10
ConstI32 20
Call 0        // Function index 0
StoreLocal 2  // Store result
```

### Task 2.3: Return Statements

**Return with value:**
```typescript
return 42;
```

**Bytecode:**
```
ConstI32 42
Return
```

**Return without value:**
```typescript
return;
```

**Bytecode:**
```
ConstNull
Return
```

### Task 2.4: Exception Handling

**Try-catch:**
```typescript
try {
    riskyOperation();
} catch (e) {
    handleError(e);
}
```

**Bytecode:**
```
PushHandler catch_label
<try block code>
PopHandler
Jmp finally_label
catch_label:
<catch block code>
finally_label:
```

### Verification (Phase 2)

**Tests:**
```rust
#[test]
fn test_compile_if_statement();
#[test]
fn test_compile_while_loop();
#[test]
fn test_compile_for_loop();
#[test]
fn test_compile_function_declaration();
#[test]
fn test_compile_function_call();
#[test]
fn test_compile_return_statement();
#[test]
fn test_compile_try_catch();
```

**Success Criteria:**
- âœ… If/else compiles correctly
- âœ… Loops compile with correct jumps
- âœ… Functions compile and callable
- âœ… Exception handling works
- âœ… 30+ tests passing

---

## Phase 3: Classes & Objects (Week 3)

**Duration:** 5-7 days
**Goal:** Compile classes, objects, arrays, and member access

### Task 3.1: Class Compilation

**Class declaration:**
```typescript
class Point {
    x: number;
    y: number;

    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }

    distance(): number {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
}
```

**Compilation:**
1. Create `ClassDef` with field layout
2. Compile constructor as special function
3. Compile methods as functions with `this` parameter
4. Register class in module

### Task 3.2: Object Creation

**New expression:**
```typescript
let p = new Point(3, 4);
```

**Bytecode:**
```
ConstI32 3
ConstI32 4
New 0         // Class index 0
Call 1        // Constructor function
StoreLocal 0
```

### Task 3.3: Member Access

**Property access:**
```typescript
let x = point.x;
```

**Bytecode:**
```
LoadLocal 0   // point
GetField 0    // Field index 0 (x)
```

**Method call:**
```typescript
let d = point.distance();
```

**Bytecode:**
```
LoadLocal 0   // point (becomes 'this')
CallMethod 0  // Method index 0
```

### Task 3.4: Arrays and Objects

**Array literal:**
```typescript
let arr = [1, 2, 3];
```

**Bytecode:**
```
ConstI32 1
ConstI32 2
ConstI32 3
MakeArray 3   // Array of 3 elements
```

**Object literal:**
```typescript
let obj = { x: 10, y: 20 };
```

**Bytecode:**
```
MakeObject 2  // Object with 2 properties
ConstStr 0    // "x"
ConstI32 10
SetProp
ConstStr 1    // "y"
ConstI32 20
SetProp
```

### Verification (Phase 3)

**Tests:**
```rust
#[test]
fn test_compile_class_declaration();
#[test]
fn test_compile_class_instantiation();
#[test]
fn test_compile_member_access();
#[test]
fn test_compile_method_call();
#[test]
fn test_compile_array_literal();
#[test]
fn test_compile_object_literal();
```

**Success Criteria:**
- âœ… Classes compile with correct layout
- âœ… Object creation works
- âœ… Member access compiles
- âœ… Arrays/objects work
- âœ… 40+ tests passing

---

## Phase 4: Advanced Features & Optimization (Week 4)

**Duration:** 5-7 days
**Goal:** Monomorphization, async/await, and optimization

### Task 4.1: Generic Monomorphization

**Generic function:**
```typescript
function identity<T>(x: T): T {
    return x;
}

let a = identity<number>(42);
let b = identity<string>("hello");
```

**Monomorphization:**
1. Detect generic instantiation
2. Create specialized version per type
3. Replace generic call with specialized call

**Generated functions:**
```rust
// identity_number (function index 0)
LoadLocal 0
Return

// identity_string (function index 1)
LoadLocal 0
Return
```

**Implementation:**

```rust
// crates/raya-compiler/src/monomorph/mod.rs
pub struct Monomorphizer {
    cache: FxHashMap<(FunctionId, Vec<TypeId>), u16>,
}

impl Monomorphizer {
    pub fn instantiate(&mut self, func: &Function, types: Vec<TypeId>) -> u16 {
        // Check cache
        if let Some(&func_idx) = self.cache.get(&(func.id, &types)) {
            return func_idx;
        }

        // Create specialized version
        let specialized = self.specialize(func, types);
        let func_idx = self.add_function(specialized);

        self.cache.insert((func.id, types), func_idx);
        func_idx
    }
}
```

### Task 4.2: Async/Await Compilation

**Async function:**
```typescript
async function fetchData(): Task<string> {
    let response = await fetch("https://api.example.com");
    return response.text();
}
```

**Compilation:**
1. Async function creates Task on call
2. `await` suspends current Task
3. Use `SPAWN` and `AWAIT` opcodes

**Bytecode:**
```
// fetchData function
ConstStr 0      // URL string
Call 1          // fetch() function
Await           // Suspend until complete
CallMethod 0    // .text()
Return

// Call site
Call 0          // fetchData()
Spawn           // Creates Task
```

### Task 4.3: Optimization Passes

**1. Constant Folding:**
```typescript
let x = 10 + 32;  // Compile to ConstI32 42
```

**2. Dead Code Elimination:**
```typescript
if (false) {
    deadCode();  // Eliminate this branch
}
```

**3. Peephole Optimization:**
```
LoadLocal 0
LoadLocal 0
```
â†’
```
LoadLocal 0
Dup
```

**Implementation:**

```rust
// crates/raya-compiler/src/optimize/mod.rs
pub struct Optimizer;

impl Optimizer {
    pub fn optimize(&self, bytecode: Vec<u8>) -> Vec<u8> {
        let mut bytecode = bytecode;
        bytecode = self.constant_fold(bytecode);
        bytecode = self.dead_code_eliminate(bytecode);
        bytecode = self.peephole_optimize(bytecode);
        bytecode
    }
}
```

### Task 4.4: Debug Information

**Source maps:**
- Track bytecode offset â†’ source location
- Enable stack traces with source info
- Help with debugging

```rust
pub struct DebugInfo {
    source_map: Vec<(usize, Span)>,  // (bytecode_offset, source_span)
    local_names: Vec<(u16, String)>,  // (local_index, name)
}
```

### Verification (Phase 4)

**Tests:**
```rust
#[test]
fn test_monomorphize_generic_function();
#[test]
fn test_compile_async_function();
#[test]
fn test_compile_await_expression();
#[test]
fn test_constant_folding();
#[test]
fn test_dead_code_elimination();
```

**Success Criteria:**
- âœ… Generic monomorphization works
- âœ… Async/await compiles correctly
- âœ… Optimizations improve bytecode
- âœ… Debug info generated
- âœ… 50+ tests passing

---

## Testing Strategy

### Unit Tests

**Test organization:**
- `codegen_tests.rs` - Expression/statement codegen
- `monomorph_tests.rs` - Generic specialization
- `optimize_tests.rs` - Optimization passes
- `integration_tests.rs` - End-to-end compilation

### Integration Tests

**Complete programs:**
```rust
#[test]
fn test_compile_fibonacci() {
    let source = r#"
        function fib(n: number): number {
            if (n <= 1) return n;
            return fib(n - 1) + fib(n - 2);
        }
    "#;

    let module = compile(source);
    assert!(module.is_ok());
}
```

### Bytecode Validation

**Verify generated bytecode:**
- Correct opcode sequences
- Valid jump targets
- Proper stack balance
- Type-consistent operations

---

## Success Criteria

### Must Have

- [ ] All Raya constructs compile to bytecode
- [ ] Type-driven opcode selection works
- [ ] Generic monomorphization functional
- [ ] Async/await compiles correctly
- [ ] Control flow compiles with correct jumps
- [ ] Classes and objects work
- [ ] 100+ comprehensive tests passing
- [ ] All examples from LANG.md compile

### Should Have

- [ ] Optimization passes improve bytecode
- [ ] Debug information generated
- [ ] Bytecode verification
- [ ] Clear compilation errors

### Nice to Have

- [ ] Constant propagation optimization
- [ ] Inline expansion for small functions
- [ ] Bytecode size metrics
- [ ] Compilation performance benchmarks

---

## References

### Language Specification

- [design/LANG.md](../design/LANG.md) - Complete language specification
- [design/OPCODE.md](../design/OPCODE.md) - Bytecode instruction set
- [design/MAPPING.md](../design/MAPPING.md) - Language â†’ bytecode mappings

### Related Milestones

- [Milestone 2.3](milestone-2.3.md) - Parser âœ…
- [Milestone 2.4](milestone-2.4.md) - Type System âœ…
- [Milestone 2.5](milestone-2.5.md) - Type Checker âœ…
- [Milestone 1.2](milestone-1.2.md) - Bytecode Definitions âœ…

### External References

- **Crafting Interpreters** - Bytecode compilation
- **Dragon Book** - Code generation techniques
- **Rust Compiler** - Monomorphization implementation

---

## Notes

### 1. Monomorphization Strategy

Follow Rust's approach:
- Generate specialized version for each type instantiation
- Cache instantiations to avoid duplicates
- Perform monomorphization during compilation (not runtime)

### 2. Async Compilation

Async functions compile to:
1. Regular function that creates a Task
2. Task executes function body
3. `await` suspends Task until value ready

### 3. Type-Driven Optimization

Use type information to:
- Select efficient opcodes (`Iadd` vs `Nadd`)
- Eliminate runtime type checks
- Optimize object layouts

### 4. Error Recovery

Compilation errors should:
- Show source location
- Explain what went wrong
- Suggest fixes where possible

---

**End of Milestone 2.6 Specification**
