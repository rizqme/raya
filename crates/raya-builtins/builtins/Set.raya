// Set - Collection of unique values
// This is a built-in type using compiler intrinsics

// Native IDs:
// SET_NEW          = 0x0900
// SET_SIZE         = 0x0901
// SET_ADD          = 0x0902
// SET_HAS          = 0x0903
// SET_DELETE       = 0x0904
// SET_CLEAR        = 0x0905
// SET_VALUES       = 0x0906
// SET_FOR_EACH     = 0x0907
// SET_UNION        = 0x0908
// SET_INTERSECTION = 0x0909
// SET_DIFFERENCE   = 0x090A

class Set<T> {
    private setPtr: number;

    constructor() {
        this.setPtr = __NATIVE_CALL(0x0900);
    }

    // Get the number of elements
    size(): number {
        return __NATIVE_CALL(0x0901, this.setPtr);
    }

    // Add a value to the set
    add(value: T): void {
        __NATIVE_CALL(0x0902, this.setPtr, value);
    }

    // Check if value exists
    has(value: T): boolean {
        return __NATIVE_CALL(0x0903, this.setPtr, value);
    }

    // Delete a value (returns true if existed)
    delete(value: T): boolean {
        return __NATIVE_CALL(0x0904, this.setPtr, value);
    }

    // Remove all elements
    clear(): void {
        __NATIVE_CALL(0x0905, this.setPtr);
    }

    // Get all values as an array
    values(): Array<T> {
        return __NATIVE_CALL(0x0906, this.setPtr);
    }

    // Iterate over all values
    forEach(fn: (value: T) => void): void {
        __NATIVE_CALL(0x0907, this.setPtr, fn);
    }

    // Return a new set containing elements from both sets
    union(other: Set<T>): Set<T> {
        return __NATIVE_CALL(0x0908, this.setPtr, other.setPtr);
    }

    // Return a new set containing elements present in both sets
    intersection(other: Set<T>): Set<T> {
        return __NATIVE_CALL(0x0909, this.setPtr, other.setPtr);
    }

    // Return a new set containing elements in this set but not in other
    difference(other: Set<T>): Set<T> {
        return __NATIVE_CALL(0x090A, this.setPtr, other.setPtr);
    }
}
