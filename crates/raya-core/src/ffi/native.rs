// Native module support API for raya-ffi
//
// Provides types and functions for registering Rust native modules with the VM.

use crate::value::Value;
use crate::vm::VmContext;
use std::collections::HashMap;

// ============================================================================
// Types
// ============================================================================

/// Native value handle for FFI functions.
///
/// This is a lightweight wrapper around Value that can be passed across FFI boundaries.
/// The actual Value is stored in the VM's value stack or heap.
///
/// # Thread Safety
///
/// NativeValue is Send + Sync because:
/// 1. The pointed-to Value is heap-allocated and uniquely owned by this handle
/// 2. The VM ensures no concurrent access during native calls (values are pinned)
/// 3. Each NativeValue owns its Value exclusively - no aliasing
///
/// # GC Safety
///
/// The VM MUST pin the Value before passing NativeValue to native code:
/// - `pin_value()` called before native function invocation
/// - `unpin_value()` called after native function returns
/// - GC will not collect pinned values (pin_count > 0)
///
/// # Safety Invariants
///
/// - Each NativeValue points to a valid, heap-allocated Value
/// - No two NativeValue instances point to the same Value
/// - The pointed-to Value is pinned during the lifetime of access
/// - Ownership is transferred on `into_value()`, pointer becomes invalid
#[repr(C)]
#[derive(Clone, Copy)]
pub struct NativeValue {
    inner: usize, // Pointer to Value (opaque)
}

// Safety: NativeValue is Send because each instance owns its Value uniquely
// and the VM ensures proper synchronization during native calls
unsafe impl Send for NativeValue {}

// Safety: NativeValue is Sync because the VM pins values during native calls
// preventing concurrent mutation. Multiple threads can hold NativeValue instances
// safely as long as the VM enforces the pinning protocol.
unsafe impl Sync for NativeValue {}

impl NativeValue {
    /// Create NativeValue from internal Value
    pub fn from_value(value: Value) -> Self {
        let boxed = Box::new(value);
        NativeValue {
            inner: Box::into_raw(boxed) as usize,
        }
    }

    /// Get internal Value reference (unsafe)
    pub unsafe fn as_value(&self) -> &Value {
        &*(self.inner as *const Value)
    }

    /// Convert to owned Value (consumes NativeValue)
    pub unsafe fn into_value(self) -> Value {
        *Box::from_raw(self.inner as *mut Value)
    }

    /// Create null value
    pub fn null() -> Self {
        NativeValue::from_value(Value::null())
    }

    /// Create error value (temporary - for now returns null)
    /// TODO: Use proper Error type once available
    pub fn error(_msg: String) -> Self {
        // For now, just return null since we don't have a proper Error type yet
        // This will be improved when we implement the Error value type
        NativeValue::null()
    }
}

/// Native function signature.
///
/// Takes array of NativeValue arguments and returns a NativeValue result.
/// Function is responsible for:
/// - Validating argument count and types
/// - Converting arguments from NativeValue to Rust types
/// - Executing the logic
/// - Converting result from Rust type to NativeValue
/// - Catching panics and returning errors
pub type NativeFn = extern "C" fn(args: *const NativeValue, arg_count: usize) -> NativeValue;

/// Native module definition.
///
/// Contains module metadata and registered functions.
///
/// # Thread Safety
///
/// NativeModule is Send + Sync because:
/// 1. After registration, it becomes immutable (no mutation methods)
/// 2. HashMap<String, NativeFn> is Send + Sync when immutable
/// 3. Function pointers (NativeFn) are inherently Send + Sync
///
/// The VM stores NativeModule in Arc<RwLock<>> or similar for thread-safe access.
#[derive(Debug)]
pub struct NativeModule {
    name: String,
    version: String,
    functions: HashMap<String, NativeFn>,
}

// Safety: NativeModule is Send because all fields are Send
// and it's immutable after registration
unsafe impl Send for NativeModule {}

// Safety: NativeModule is Sync because it's immutable after registration
// and all fields are Sync (String, HashMap with Sync contents, NativeFn)
unsafe impl Sync for NativeModule {}

impl NativeModule {
    /// Create a new native module.
    ///
    /// # Arguments
    /// * `name` - Module name (e.g., "json", "fs")
    /// * `version` - Semantic version (e.g., "1.0.0")
    pub fn new(name: impl Into<String>, version: impl Into<String>) -> Self {
        NativeModule {
            name: name.into(),
            version: version.into(),
            functions: HashMap::new(),
        }
    }

    /// Register a function with the module.
    ///
    /// # Arguments
    /// * `name` - Function name
    /// * `func` - Function pointer (generated by #[function] macro)
    pub fn register_function(&mut self, name: impl Into<String>, func: NativeFn) {
        self.functions.insert(name.into(), func);
    }

    /// Get module name
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Get module version
    pub fn version(&self) -> &str {
        &self.version
    }

    /// Get function by name
    pub fn get_function(&self, name: &str) -> Option<NativeFn> {
        self.functions.get(name).copied()
    }

    /// Get all function names
    pub fn function_names(&self) -> Vec<&str> {
        self.functions.keys().map(|s| s.as_str()).collect()
    }

    /// Get all function names (alias for function_names)
    pub fn functions(&self) -> Vec<String> {
        self.functions.keys().cloned().collect()
    }
}

// ============================================================================
// Error Type
// ============================================================================

/// Native module error types
#[derive(Debug, Clone, thiserror::Error)]
pub enum NativeError {
    #[error("Type mismatch: expected {expected}, got {got}")]
    TypeMismatch { expected: String, got: String },

    #[error("Argument error: {0}")]
    ArgumentError(String),

    #[error("Function panicked: {0}")]
    Panic(String),

    #[error("Module error: {0}")]
    ModuleError(String),
}

// ============================================================================
// Value Conversion Traits (Runtime implementations)
// ============================================================================

/// Convert from NativeValue to Rust type (runtime type checking).
pub trait FromRaya: Sized {
    fn from_raya(value: NativeValue) -> Result<Self, NativeError>;
}

/// Convert from Rust type to NativeValue.
pub trait ToRaya {
    fn to_raya(self) -> NativeValue;
}

// ============================================================================
// Primitive Type Implementations
// ============================================================================

impl FromRaya for i32 {
    fn from_raya(value: NativeValue) -> Result<Self, NativeError> {
        unsafe {
            value.as_value().as_i32().ok_or_else(|| NativeError::TypeMismatch {
                expected: "i32".to_string(),
                got: "other".to_string(), // TODO: Better type names
            })
        }
    }
}

impl ToRaya for i32 {
    fn to_raya(self) -> NativeValue {
        NativeValue::from_value(Value::i32(self))
    }
}

impl FromRaya for f64 {
    fn from_raya(value: NativeValue) -> Result<Self, NativeError> {
        unsafe {
            value.as_value().as_f64().ok_or_else(|| NativeError::TypeMismatch {
                expected: "f64".to_string(),
                got: "other".to_string(),
            })
        }
    }
}

impl ToRaya for f64 {
    fn to_raya(self) -> NativeValue {
        NativeValue::from_value(Value::f64(self))
    }
}

impl FromRaya for bool {
    fn from_raya(value: NativeValue) -> Result<Self, NativeError> {
        unsafe {
            value.as_value().as_bool().ok_or_else(|| NativeError::TypeMismatch {
                expected: "bool".to_string(),
                got: "other".to_string(),
            })
        }
    }
}

impl ToRaya for bool {
    fn to_raya(self) -> NativeValue {
        NativeValue::from_value(Value::bool(self))
    }
}

// String support is complex - skip for now
// TODO: Implement once we have proper string heap allocation
// impl FromRaya for String { ... }
// impl ToRaya for String { ... }

// Unit type (for functions that return void)
impl ToRaya for () {
    fn to_raya(self) -> NativeValue {
        NativeValue::null()
    }
}

// Result type (for fallible functions)
impl<T: ToRaya, E: ToString> ToRaya for Result<T, E> {
    fn to_raya(self) -> NativeValue {
        match self {
            Ok(value) => value.to_raya(),
            Err(error) => NativeValue::error(error.to_string()),
        }
    }
}

// ============================================================================
// GC Pinning Functions (Stubs for now)
// ============================================================================

/// Pin a value to prevent GC from moving/freeing it.
///
/// MUST be called by the VM before passing a value to native code.
/// The GC will not collect any value with pin_count > 0.
///
/// # Safety
///
/// This function is safe to call, but the VM must ensure proper pairing
/// with `unpin_value()`. Failure to unpin will cause memory leaks.
///
/// # Thread Safety
///
/// This function uses atomic operations and is safe to call from any thread.
///
/// # Current Implementation
///
/// This is currently a no-op stub. Full implementation will:
/// 1. Locate the ValueHeader for this value
/// 2. Atomically increment pin_count with Ordering::AcqRel
/// 3. Ensure the value is visible to all threads
///
/// # Future Implementation
///
/// ```rust,ignore
/// pub fn pin_value(value: NativeValue) {
///     unsafe {
///         let header = get_value_header(value);
///         header.pin_count.fetch_add(1, Ordering::AcqRel);
///     }
/// }
/// ```
pub fn pin_value(_value: NativeValue) {
    // TODO: Implement atomic pin_count increment
    // See design/ABI_SAFETY.md for full specification
}

/// Unpin a value to allow GC to collect it.
///
/// MUST be called by the VM after a native function returns.
/// Should be used with RAII guards to ensure unpinning even on panic.
///
/// # Safety
///
/// This function is safe to call, but panics if the value is not pinned
/// (debug builds only). The VM must not unpin a value more times than it
/// was pinned.
///
/// # Thread Safety
///
/// This function uses atomic operations and is safe to call from any thread.
///
/// # Current Implementation
///
/// This is currently a no-op stub. Full implementation will:
/// 1. Locate the ValueHeader for this value
/// 2. Atomically decrement pin_count with Ordering::AcqRel
/// 3. Assert pin_count was > 0 (debug builds)
///
/// # Future Implementation
///
/// ```rust,ignore
/// pub fn unpin_value(value: NativeValue) {
///     unsafe {
///         let header = get_value_header(value);
///         let old_count = header.pin_count.fetch_sub(1, Ordering::AcqRel);
///         debug_assert!(old_count > 0, "Unpin called on unpinned value");
///     }
/// }
/// ```
pub fn unpin_value(_value: NativeValue) {
    // TODO: Implement atomic pin_count decrement
    // See design/ABI_SAFETY.md for full specification
}

// ============================================================================
// VM Context Extension (Helper function for now)
// ============================================================================

/// Register a native module with the VM context.
///
/// The module will be available to Raya code via standard imports.
/// Users won't know the difference between native and bytecode modules:
///
/// ```raya
/// // These look the same to users, but json is native, mylib is bytecode
/// import { parse } from "std:json";
/// import { helper } from "custom:mylib";
/// ```
///
/// The module resolver automatically detects whether to load:
/// - `.rbin` files (bytecode modules)
/// - `.so/.dylib/.dll` files (native modules)
///
/// TODO: This should be a method on VmContext once we add native module storage.
pub fn register_native_module(vm: &mut VmContext, module: NativeModule) -> Result<(), String> {
    // TODO: Store module in VM context's module registry
    // The module resolver will check native modules first, then bytecode
    // For now, just log registration
    println!(
        "Registered native module '{}' v{} with {} functions",
        module.name(),
        module.version(),
        module.functions.len()
    );

    Ok(())
}
