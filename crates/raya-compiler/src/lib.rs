//! Raya Compiler - AST to Bytecode Code Generation
//!
//! This crate implements the compiler that transforms typed AST into bytecode.
//!
//! # Architecture
//!
//! The compilation pipeline is:
//! 1. AST (from raya-parser) → IR (intermediate representation)
//! 2. IR → Monomorphization (generic specialization)
//! 3. IR → Optimizations (constant folding, DCE)
//! 4. IR → Bytecode
//!
//! The IR uses Three-Address Code (TAC) with Basic Blocks.

pub mod bytecode;
pub mod codegen;
pub mod codegen_ast;
pub mod error;
pub mod ir;
pub mod lower;
pub mod module_builder;
pub mod monomorphize;
pub mod optimize;

pub use codegen_ast::CodeGenerator;
pub use codegen::IrCodeGenerator;
pub use error::{CompileError, CompileResult};
pub use module_builder::ModuleBuilder;

// Re-export bytecode types for convenience
pub use bytecode::{
    BytecodeReader, BytecodeWriter, ClassDef, ConstantPool, DecodeError, Export, Function,
    Import, Metadata, Method, Module, ModuleError, Opcode, SymbolType, VerifyError, verify_module,
};

use raya_parser::ast;
use raya_parser::Interner;
use raya_parser::TypeContext;

/// Main compiler entry point
pub struct Compiler<'a> {
    type_ctx: TypeContext,
    interner: &'a Interner,
}

impl<'a> Compiler<'a> {
    pub fn new(type_ctx: TypeContext, interner: &'a Interner) -> Self {
        Self { type_ctx, interner }
    }

    /// Compile a module into bytecode
    pub fn compile(&mut self, module: &ast::Module) -> CompileResult<Module> {
        let mut codegen = CodeGenerator::new(&self.type_ctx, self.interner);
        codegen.compile_program(module)
    }

    /// Compile a module to IR (for debugging/inspection)
    pub fn compile_to_ir(&self, module: &ast::Module) -> ir::IrModule {
        let mut lowerer = lower::Lowerer::new(&self.type_ctx, self.interner);
        lowerer.lower_module(module)
    }

    /// Compile a module to IR with monomorphization
    ///
    /// This performs the full IR compilation pipeline including:
    /// 1. AST lowering to IR
    /// 2. Monomorphization (generic specialization)
    /// 3. Optimization passes
    pub fn compile_to_optimized_ir(&self, module: &ast::Module) -> ir::IrModule {
        // Step 1: Lower AST to IR
        let mut lowerer = lower::Lowerer::new(&self.type_ctx, self.interner);
        let mut ir_module = lowerer.lower_module(module);

        // Step 2: Monomorphization
        let _mono_result = monomorphize::monomorphize(&mut ir_module, &self.type_ctx, self.interner);

        // Step 3: Optimization passes
        let optimizer = optimize::Optimizer::basic();
        optimizer.optimize(&mut ir_module);

        ir_module
    }

    /// Compile a module through the full IR pipeline to bytecode
    ///
    /// This is the preferred compilation path that uses:
    /// 1. AST → IR lowering
    /// 2. Monomorphization
    /// 3. Optimizations
    /// 4. IR → Bytecode code generation
    pub fn compile_via_ir(&self, module: &ast::Module) -> CompileResult<Module> {
        // Get optimized IR
        let ir_module = self.compile_to_optimized_ir(module);

        // Generate bytecode from IR
        codegen::generate(&ir_module)
    }

    /// Compile a module through the full IR pipeline with verification
    ///
    /// Same as compile_via_ir but also verifies the generated bytecode.
    pub fn compile_via_ir_verified(&self, module: &ast::Module) -> CompileResult<Module> {
        let bytecode_module = self.compile_via_ir(module)?;

        // Verify the generated bytecode
        verify_module(&bytecode_module).map_err(|e| CompileError::Verification {
            message: e.to_string(),
        })?;

        Ok(bytecode_module)
    }

    /// Compile with debug output
    ///
    /// Returns both the bytecode module and a debug string showing IR and bytecode.
    pub fn compile_with_debug(&self, module: &ast::Module) -> CompileResult<(Module, String)> {
        use ir::PrettyPrint;
        use std::fmt::Write;

        let mut debug = String::new();

        // Step 1: Lower AST to IR
        let mut lowerer = lower::Lowerer::new(&self.type_ctx, self.interner);
        let mut ir_module = lowerer.lower_module(module);

        writeln!(debug, "=== IR Before Optimization ===").unwrap();
        writeln!(debug, "{}", ir_module.pretty_print()).unwrap();

        // Step 2: Monomorphization
        let mono_result = monomorphize::monomorphize(&mut ir_module, &self.type_ctx, self.interner);
        writeln!(debug, "=== Monomorphization Stats ===").unwrap();
        writeln!(debug, "Functions specialized: {}", mono_result.functions_specialized).unwrap();
        writeln!(debug, "Classes specialized: {}", mono_result.classes_specialized).unwrap();

        // Step 3: Optimization passes
        let optimizer = optimize::Optimizer::basic();
        optimizer.optimize(&mut ir_module);

        writeln!(debug, "\n=== IR After Optimization ===").unwrap();
        writeln!(debug, "{}", ir_module.pretty_print()).unwrap();

        // Step 4: Generate bytecode
        let bytecode_module = codegen::generate(&ir_module)?;

        writeln!(debug, "=== Generated Bytecode ===").unwrap();
        for (i, func) in bytecode_module.functions.iter().enumerate() {
            writeln!(debug, "Function {}: {} (locals: {}, params: {})",
                i, func.name, func.local_count, func.param_count).unwrap();
            writeln!(debug, "  Code size: {} bytes", func.code.len()).unwrap();
            writeln!(debug, "  Disassembly:").unwrap();
            writeln!(debug, "{}", disassemble_function(func)).unwrap();
        }

        Ok((bytecode_module, debug))
    }
}

/// Disassemble a function's bytecode into human-readable form
pub fn disassemble_function(func: &Function) -> String {
    use std::fmt::Write;

    let mut output = String::new();
    let code = &func.code;
    let mut offset = 0;

    while offset < code.len() {
        let opcode_byte = code[offset];
        if let Some(opcode) = Opcode::from_u8(opcode_byte) {
            write!(output, "    {:04x}: {:?}", offset, opcode).unwrap();
            offset += 1;

            // Read operands based on opcode
            let operand_size = codegen::emit::opcode_size(opcode) - 1;
            if operand_size > 0 && offset + operand_size <= code.len() {
                match operand_size {
                    2 => {
                        let val = u16::from_le_bytes([code[offset], code[offset + 1]]);
                        write!(output, " {}", val).unwrap();
                    }
                    4 => {
                        let val = i32::from_le_bytes([
                            code[offset], code[offset + 1],
                            code[offset + 2], code[offset + 3],
                        ]);
                        write!(output, " {}", val).unwrap();
                    }
                    6 => {
                        let val1 = u32::from_le_bytes([
                            code[offset], code[offset + 1],
                            code[offset + 2], code[offset + 3],
                        ]);
                        let val2 = u16::from_le_bytes([code[offset + 4], code[offset + 5]]);
                        write!(output, " {} {}", val1, val2).unwrap();
                    }
                    8 => {
                        let val = f64::from_le_bytes([
                            code[offset], code[offset + 1], code[offset + 2], code[offset + 3],
                            code[offset + 4], code[offset + 5], code[offset + 6], code[offset + 7],
                        ]);
                        write!(output, " {}", val).unwrap();
                    }
                    _ => {}
                }
                offset += operand_size;
            }
            writeln!(output).unwrap();
        } else {
            writeln!(output, "    {:04x}: <invalid opcode {:#x}>", offset, opcode_byte).unwrap();
            offset += 1;
        }
    }

    output
}
