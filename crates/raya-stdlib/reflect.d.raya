/**
 * std:reflect - Runtime Reflection API
 *
 * Provides runtime introspection and manipulation of classes, methods, and fields.
 * This module is foundational for decorators and dependency injection.
 *
 * Usage:
 *   import * as Reflect from "std:reflect";
 */

// ============================================================================
// Standard Decorator Metadata Keys
// ============================================================================

/**
 * Standard metadata key for design-time type information on fields/parameters.
 * Value: type name string (e.g., "string", "number", "MyClass")
 *
 * Automatically emitted by compiler when using decorators on typed fields.
 */
export const DESIGN_TYPE: string = "design:type";

/**
 * Standard metadata key for parameter types of a method.
 * Value: string[] of parameter type names
 *
 * Automatically emitted by compiler when using decorators on methods.
 */
export const DESIGN_PARAM_TYPES: string = "design:paramtypes";

/**
 * Standard metadata key for return type of a method.
 * Value: type name string
 *
 * Automatically emitted by compiler when using decorators on methods.
 */
export const DESIGN_RETURN_TYPE: string = "design:returntype";

/**
 * Metadata key for storing decorator information on a class.
 * Value: DecoratorInfo[]
 *
 * Emitted when decorators are applied to classes, methods, or fields.
 */
export const DECORATORS: string = "reflect:decorators";

/**
 * Metadata key for storing the class constructor reference.
 * Value: Class<T> reference
 *
 * Used by dependency injection frameworks.
 */
export const CONSTRUCTOR: string = "reflect:constructor";

// ============================================================================
// Decorator Information Types
// ============================================================================

/**
 * Information about an applied decorator
 */
export interface DecoratorInfo {
    /** Decorator function name */
    readonly name: string;
    /** Arguments passed to the decorator factory (if any) */
    readonly args: readonly any[];
    /** Target type: "class", "method", "field", or "parameter" */
    readonly targetType: "class" | "method" | "field" | "parameter";
    /** Property key for method/field/parameter decorators */
    readonly propertyKey?: string;
    /** Parameter index for parameter decorators */
    readonly parameterIndex?: number;
}

// ============================================================================
// Decorator Registration (used by codegen, rarely called directly)
// ============================================================================

/**
 * Register a decorator application on a class
 * Called by generated code to track decorator applications
 * @param classId - Class ID
 * @param decoratorName - Name of the decorator function
 * @param args - Arguments passed to the decorator factory
 */
export function registerClassDecorator(classId: number, decoratorName: string, args?: any[]): void;

/**
 * Register a decorator application on a method
 * @param classId - Class ID
 * @param methodName - Method name
 * @param decoratorName - Name of the decorator function
 * @param args - Arguments passed to the decorator factory
 */
export function registerMethodDecorator(classId: number, methodName: string, decoratorName: string, args?: any[]): void;

/**
 * Register a decorator application on a field
 * @param classId - Class ID
 * @param fieldName - Field name
 * @param decoratorName - Name of the decorator function
 * @param args - Arguments passed to the decorator factory
 */
export function registerFieldDecorator(classId: number, fieldName: string, decoratorName: string, args?: any[]): void;

/**
 * Register a decorator application on a parameter
 * @param classId - Class ID
 * @param methodName - Method name
 * @param paramIndex - Parameter index (0-based)
 * @param decoratorName - Name of the decorator function
 * @param args - Arguments passed to the decorator factory
 */
export function registerParameterDecorator(classId: number, methodName: string, paramIndex: number, decoratorName: string, args?: any[]): void;

/**
 * Get all classes that have a specific decorator applied
 * @param decoratorName - Name of the decorator to search for
 * @returns Array of class IDs that have the decorator
 */
export function getClassesWithDecorator(decoratorName: string): number[];

/**
 * Get all decorators applied to a class
 * @param classId - Class ID
 * @returns Array of DecoratorInfo objects
 */
export function getClassDecorators(classId: number): DecoratorInfo[];

/**
 * Get all decorators applied to a method
 * @param classId - Class ID
 * @param methodName - Method name
 * @returns Array of DecoratorInfo objects
 */
export function getMethodDecorators(classId: number, methodName: string): DecoratorInfo[];

/**
 * Get all decorators applied to a field
 * @param classId - Class ID
 * @param fieldName - Field name
 * @returns Array of DecoratorInfo objects
 */
export function getFieldDecorators(classId: number, fieldName: string): DecoratorInfo[];

// ============================================================================
// Metadata Operations
// ============================================================================

/**
 * Define metadata on a target
 * @param key - Metadata key
 * @param value - Metadata value
 * @param target - Target object or class
 */
export function defineMetadata(key: string, value: any, target: any): void;

/**
 * Define metadata on a property
 * @param key - Metadata key
 * @param value - Metadata value
 * @param target - Target object or class
 * @param propertyKey - Property name
 */
export function defineMetadata(key: string, value: any, target: any, propertyKey: string): void;

/**
 * Get metadata from a target
 * @param key - Metadata key
 * @param target - Target object or class
 * @returns The metadata value or null
 */
export function getMetadata(key: string, target: any): any;

/**
 * Get metadata from a property
 * @param key - Metadata key
 * @param target - Target object or class
 * @param propertyKey - Property name
 * @returns The metadata value or null
 */
export function getMetadata(key: string, target: any, propertyKey: string): any;

/**
 * Check if target has metadata
 * @param key - Metadata key
 * @param target - Target object or class
 * @returns true if metadata exists
 */
export function hasMetadata(key: string, target: any): boolean;

/**
 * Check if property has metadata
 * @param key - Metadata key
 * @param target - Target object or class
 * @param propertyKey - Property name
 * @returns true if metadata exists
 */
export function hasMetadata(key: string, target: any, propertyKey: string): boolean;

/**
 * Get all metadata keys on a target
 * @param target - Target object or class
 * @returns Array of metadata keys
 */
export function getMetadataKeys(target: any): string[];

/**
 * Get all metadata keys on a property
 * @param target - Target object or class
 * @param propertyKey - Property name
 * @returns Array of metadata keys
 */
export function getMetadataKeys(target: any, propertyKey: string): string[];

/**
 * Delete metadata from a target
 * @param key - Metadata key
 * @param target - Target object or class
 * @returns true if metadata was deleted
 */
export function deleteMetadata(key: string, target: any): boolean;

/**
 * Delete metadata from a property
 * @param key - Metadata key
 * @param target - Target object or class
 * @param propertyKey - Property name
 * @returns true if metadata was deleted
 */
export function deleteMetadata(key: string, target: any, propertyKey: string): boolean;

// ============================================================================
// Class Introspection
// ============================================================================

/**
 * Get the class ID of an object
 * @param obj - Object instance
 * @returns Class ID or null if not a class instance
 */
export function getClass<T>(obj: T): number | null;

/**
 * Look up a class by name
 * @param name - Class name
 * @returns Class ID or null if not found
 */
export function getClassByName(name: string): number | null;

/**
 * Get all registered class IDs
 * @returns Array of class IDs
 */
export function getAllClasses(): number[];

/**
 * Get classes with a specific decorator
 * @param decorator - Decorator name
 * @returns Array of class IDs
 */
export function getClassesWithDecorator(decorator: string): number[];

/**
 * Check if one class is a subclass of another
 * @param subClassId - Potential subclass ID
 * @param superClassId - Potential superclass ID
 * @returns true if subClassId extends superClassId
 */
export function isSubclassOf(subClassId: number, superClassId: number): boolean;

/**
 * Check if an object is an instance of a class
 * @param obj - Object to check
 * @param classId - Class ID to check against
 * @returns true if obj is an instance of the class
 */
export function isInstanceOf(obj: any, classId: number): boolean;

/**
 * Get type information for a value
 * @param target - Value to inspect
 * @returns Type name string
 */
export function getTypeInfo(target: any): string;

/**
 * Get the inheritance hierarchy for an object
 * @param obj - Object instance
 * @returns Array of class IDs from most specific to most general
 */
export function getClassHierarchy(obj: any): number[];

// ============================================================================
// Field Access
// ============================================================================

/**
 * Get a field value by name
 * @param target - Object instance
 * @param propertyKey - Field name
 * @returns Field value or null
 */
export function get(target: any, propertyKey: string): any;

/**
 * Set a field value by name
 * @param target - Object instance
 * @param propertyKey - Field name
 * @param value - Value to set
 * @returns true if successful
 */
export function set(target: any, propertyKey: string, value: any): boolean;

/**
 * Check if an object has a field
 * @param target - Object instance
 * @param propertyKey - Field name
 * @returns true if field exists
 */
export function has(target: any, propertyKey: string): boolean;

/**
 * Get all field names of an object
 * @param target - Object instance
 * @returns Array of field names
 */
export function getFieldNames(target: any): string[];

/**
 * Field information structure
 */
export interface FieldInfo {
    name: string;
    type: string;
    index: number;
    isStatic: boolean;
    isReadonly: boolean;
    declaringClass: number;
}

/**
 * Get detailed information about a field
 * @param target - Object instance
 * @param propertyKey - Field name
 * @returns FieldInfo or null
 */
export function getFieldInfo(target: any, propertyKey: string): FieldInfo | null;

/**
 * Get all field infos for an object
 * @param target - Object instance
 * @returns Array of FieldInfo
 */
export function getFields(target: any): FieldInfo[];

/**
 * Get static field names for a class
 * @param classId - Class ID
 * @returns Array of static field names
 */
export function getStaticFieldNames(classId: number): string[];

/**
 * Get static field infos for a class
 * @param classId - Class ID
 * @returns Array of FieldInfo for static fields
 */
export function getStaticFields(classId: number): FieldInfo[];

// ============================================================================
// Method Invocation
// ============================================================================

/**
 * Check if an object has a method
 * @param target - Object instance
 * @param methodName - Method name
 * @returns true if method exists
 */
export function hasMethod(target: any, methodName: string): boolean;

/**
 * Method information structure
 */
export interface MethodInfo {
    name: string;
    parameterCount: number;
    isStatic: boolean;
    isAsync: boolean;
    declaringClass: number;
}

/**
 * Get method information
 * @param target - Object instance
 * @param methodName - Method name
 * @returns MethodInfo or null
 */
export function getMethodInfo(target: any, methodName: string): MethodInfo | null;

/**
 * Get all methods of an object
 * @param target - Object instance
 * @returns Array of MethodInfo
 */
export function getMethods(target: any): MethodInfo[];

/**
 * Get a method as a callable function
 * @param target - Object instance
 * @param methodName - Method name
 * @returns Function or null
 */
export function getMethod(target: any, methodName: string): Function | null;

/**
 * Invoke a method dynamically
 * @param target - Object instance
 * @param methodName - Method name
 * @param args - Arguments to pass
 * @returns Method return value
 */
export function invoke(target: any, methodName: string, ...args: any[]): any;

/**
 * Invoke an async method dynamically
 * @param target - Object instance
 * @param methodName - Method name
 * @param args - Arguments to pass
 * @returns Promise of method return value
 */
export function invokeAsync(target: any, methodName: string, ...args: any[]): Promise<any>;

/**
 * Invoke a static method dynamically
 * @param classId - Class ID
 * @param methodName - Method name
 * @param args - Arguments to pass
 * @returns Method return value
 */
export function invokeStatic(classId: number, methodName: string, ...args: any[]): any;

/**
 * Get static methods of a class
 * @param classId - Class ID
 * @returns Array of MethodInfo
 */
export function getStaticMethods(classId: number): MethodInfo[];

// ============================================================================
// Object Creation
// ============================================================================

/**
 * Create a new instance of a class
 * @param classId - Class ID
 * @param args - Constructor arguments
 * @returns New instance
 */
export function construct(classId: number, ...args: any[]): any;

/**
 * Allocate an uninitialized instance
 * @param classId - Class ID
 * @returns Uninitialized instance (fields are null)
 */
export function allocate(classId: number): any;

/**
 * Create a shallow clone of an object
 * @param obj - Object to clone
 * @returns Cloned object
 */
export function clone<T>(obj: T): T;

/**
 * Create a deep clone of an object
 * @param obj - Object to clone
 * @returns Deep cloned object
 */
export function deepClone<T>(obj: T): T;

/**
 * Constructor information structure
 */
export interface ConstructorInfo {
    parameterCount: number;
    parameterTypes: string[];
}

/**
 * Get constructor information for a class
 * @param classId - Class ID
 * @returns ConstructorInfo or null
 */
export function getConstructorInfo(classId: number): ConstructorInfo | null;

// ============================================================================
// Type Utilities
// ============================================================================

/**
 * Check if a value is a string
 * @param value - Value to check
 * @returns true if value is a string
 */
export function isString(value: any): boolean;

/**
 * Check if a value is a number
 * @param value - Value to check
 * @returns true if value is a number
 */
export function isNumber(value: any): boolean;

/**
 * Check if a value is a boolean
 * @param value - Value to check
 * @returns true if value is a boolean
 */
export function isBoolean(value: any): boolean;

/**
 * Check if a value is null
 * @param value - Value to check
 * @returns true if value is null
 */
export function isNull(value: any): boolean;

/**
 * Check if a value is an array
 * @param value - Value to check
 * @returns true if value is an array
 */
export function isArray(value: any): boolean;

/**
 * Check if a value is a function
 * @param value - Value to check
 * @returns true if value is a function
 */
export function isFunction(value: any): boolean;

/**
 * Check if a value is an object (class instance)
 * @param value - Value to check
 * @returns true if value is an object
 */
export function isObject(value: any): boolean;

/**
 * Type information structure
 */
export interface TypeInfo {
    kind: string;
    name: string;
    classId?: number;
}

/**
 * Get type information from a type name
 * @param typeName - The name of the type (e.g., "string", "number", "MyClass")
 * @returns TypeInfo or null if type not found
 */
export function typeOf(typeName: string): TypeInfo | null;

/**
 * Check if a source type is assignable to a target type
 * @param sourceType - Source type name
 * @param targetType - Target type name
 * @returns true if source is assignable to target
 */
export function isAssignableTo(sourceType: string, targetType: string): boolean;

/**
 * Safe cast - returns null if the value is not an instance of the class
 * @param value - Value to cast
 * @param classId - Target class ID
 * @returns The value if compatible, null otherwise
 */
export function cast<T>(value: any, classId: number): T | null;

/**
 * Cast that throws an error if the value is not an instance of the class
 * @param value - Value to cast
 * @param classId - Target class ID
 * @returns The value if compatible
 * @throws TypeError if cast fails
 */
export function castOrThrow<T>(value: any, classId: number): T;

// ============================================================================
// Interface and Hierarchy Query
// ============================================================================

/**
 * Check if a class implements an interface
 * @param classId - Class ID
 * @param interfaceName - Interface name
 * @returns true if class implements interface
 */
export function implements_(classId: number, interfaceName: string): boolean;

/**
 * Get interfaces implemented by a class
 * @param classId - Class ID
 * @returns Array of interface names
 */
export function getInterfaces(classId: number): string[];

/**
 * Get the superclass of a class
 * @param classId - Class ID
 * @returns Parent class ID or null if no parent
 */
export function getSuperclass(classId: number): number | null;

/**
 * Get direct subclasses of a class
 * @param classId - Class ID
 * @returns Array of subclass IDs
 */
export function getSubclasses(classId: number): number[];

/**
 * Get all classes that implement a given interface
 * @param interfaceName - Interface name
 * @returns Array of class IDs implementing the interface
 */
export function getImplementors(interfaceName: string): number[];

/**
 * Check if two classes are structurally compatible
 * A class is structurally compatible if it has all fields and methods of the target.
 * @param sourceClassId - Source class ID
 * @param targetClassId - Target class ID
 * @returns true if source is structurally compatible with target
 */
export function isStructurallyCompatible(sourceClassId: number, targetClassId: number): boolean;

// ============================================================================
// Object Inspection & DevTools
// ============================================================================

/**
 * Get a human-readable representation of an object
 * @param obj - Object to inspect
 * @param depth - Maximum depth to inspect (default: 2)
 * @returns Human-readable string representation
 */
export function inspect(obj: any, depth?: number): string;

/**
 * Get a unique identifier for an object (for tracking/debugging)
 * @param obj - Object to get ID for
 * @returns Unique object identifier, or 0 for primitives
 */
export function getObjectId(obj: any): number;

/**
 * Get a detailed description of a class
 * @param classId - Class ID to describe
 * @returns Human-readable class description
 */
export function describe(classId: number): string;

/**
 * Object snapshot for state tracking
 */
export interface ObjectSnapshot {
    className: string;
    fields: Map<string, FieldSnapshot>;
    identity: number;
    timestamp: number;
}

/**
 * Field snapshot data
 */
export interface FieldSnapshot {
    name: string;
    value: any;
    type: string;
}

/**
 * Capture a snapshot of an object's state
 * @param obj - Object to snapshot
 * @returns Object snapshot with class name, identity, timestamp, and field values
 */
export function snapshot(obj: any): ObjectSnapshot;

/**
 * Object diff result
 */
export interface ObjectDiff {
    added: string[];
    removed: string[];
    changed: Map<string, { old: any; new: any }>;
}

/**
 * Compare two objects or snapshots
 * @param a - First object or snapshot
 * @param b - Second object or snapshot
 * @returns Differences between objects (added, removed, changed fields)
 */
export function diff(a: any, b: any): ObjectDiff;

// ============================================================================
// Memory Analysis
// ============================================================================

/**
 * Get the shallow memory size of an object in bytes
 * @param obj - Object to measure
 * @returns Approximate size in bytes
 */
export function getObjectSize(obj: any): number;

/**
 * Get the retained size of an object (including referenced objects)
 * @param obj - Object to measure
 * @returns Retained size in bytes (traverses object graph)
 */
export function getRetainedSize(obj: any): number;

/**
 * Get objects referenced by this object
 * @param obj - Object to analyze
 * @returns Array of referenced objects
 */
export function getReferences(obj: any): any[];

/**
 * Get objects that reference this object
 * @param obj - Object to find referrers for
 * @returns Array of referrer objects (scans heap allocations)
 */
export function getReferrers(obj: any): any[];

/**
 * Heap statistics
 */
export interface HeapStats {
    totalObjects: number;
    totalBytes: number;
    byClass: Map<string, { count: number; bytes: number }>;
}

/**
 * Get heap statistics
 * @returns Heap stats with total objects, bytes, and breakdown by class
 */
export function getHeapStats(): HeapStats;

/**
 * Find all live instances of a class
 * @param classId - Class ID to find instances of
 * @returns Array of all live instances (scans heap)
 */
export function findInstances(classId: number): any[];

// ============================================================================
// Stack Introspection
// ============================================================================

/**
 * Call frame information
 */
export interface CallFrame {
    functionName: string;
    className: string | null;
    args: any[];
    sourceFile: string | null;
    line: number | null;
    column: number | null;
}

/**
 * Get the current call stack
 * @returns Array of call frames with function names and class info
 */
export function getCallStack(): CallFrame[];

/**
 * Get local variables in a stack frame
 * @param frameIndex - Frame index (0 = current, default: 0)
 * @returns Array of local variable values by index
 */
export function getLocals(frameIndex?: number): any[];

/**
 * Source location information
 */
export interface SourceLocation {
    file: string;
    line: number;
    column: number;
}

/**
 * Get source location for a method
 * @param classId - Class ID
 * @param methodName - Method name
 * @returns Source location or null (requires --emit-debug flag during compilation)
 */
export function getSourceLocation(classId: number, methodName: string): SourceLocation | null;

// ============================================================================
// Serialization Helpers
// ============================================================================

/**
 * Convert an object to JSON string
 * @param obj - Object to serialize
 * @returns JSON string representation
 */
export function toJSON(obj: any): string;

/**
 * Get enumerable keys of an object (suitable for iteration)
 * @param obj - Object to get keys from
 * @returns Array of enumerable key names
 */
export function getEnumerableKeys(obj: any): string[];

/**
 * Check if an object contains circular references
 * @param obj - Object to check
 * @returns true if object has circular references
 */
export function isCircular(obj: any): boolean;

// ============================================================================
// Proxy Objects (Phase 9)
// ============================================================================

/**
 * Handler interface for proxy traps
 * Each trap is optional - if not provided, the operation passes through to target
 */
export interface ProxyHandler<T> {
    /**
     * Intercept property read
     * @param target - The target object
     * @param property - Property name being accessed
     * @returns The property value
     */
    get?(target: T, property: string): any;

    /**
     * Intercept property write
     * @param target - The target object
     * @param property - Property name being set
     * @param value - Value being assigned
     * @returns true if the assignment should proceed
     */
    set?(target: T, property: string, value: any): boolean;

    /**
     * Intercept property existence check (in operator)
     * @param target - The target object
     * @param property - Property name being checked
     * @returns true if property exists
     */
    has?(target: T, property: string): boolean;

    /**
     * Intercept method calls
     * @param target - The target object
     * @param method - Method name being called
     * @param args - Arguments passed to method
     * @returns The method return value
     */
    invoke?(target: T, method: string, args: any[]): any;
}

/**
 * Create a proxy object that intercepts property access and method calls
 * @param target - The target object to wrap
 * @param handler - Handler object with trap functions
 * @returns A proxy object that delegates operations through the handler
 */
export function createProxy<T extends object>(target: T, handler: ProxyHandler<T>): T;

/**
 * Check if an object is a proxy
 * @param obj - Object to check
 * @returns true if obj is a proxy created with createProxy
 */
export function isProxy(obj: any): boolean;

/**
 * Get the underlying target of a proxy
 * @param proxy - Proxy object
 * @returns The original target object, or null if not a proxy
 */
export function getProxyTarget<T extends object>(proxy: T): T | null;

/**
 * Get the handler of a proxy
 * @param proxy - Proxy object
 * @returns The handler object, or null if not a proxy
 */
export function getProxyHandler<T extends object>(proxy: T): ProxyHandler<T> | null;

// ============================================================================
// Parameter Information (Phase 11)
// ============================================================================

/**
 * Parameter information structure
 */
export interface ParameterInfo {
    /** Parameter name */
    readonly name: string;
    /** Parameter type name */
    readonly type: string;
    /** Parameter index (0-based) */
    readonly index: number;
    /** Whether the parameter is optional */
    readonly isOptional: boolean;
    /** Default value expression (string representation) or null */
    readonly defaultValue: string | null;
}

/**
 * Access modifiers for fields and methods
 */
export interface Modifiers {
    /** Is publicly accessible */
    readonly isPublic: boolean;
    /** Is privately accessible (class-only) */
    readonly isPrivate: boolean;
    /** Is protected (class and subclasses) */
    readonly isProtected: boolean;
    /** Is a static member */
    readonly isStatic: boolean;
    /** Is readonly (cannot be reassigned) */
    readonly isReadonly: boolean;
    /** Is abstract (must be implemented by subclass) */
    readonly isAbstract: boolean;
}

/**
 * Get parameter information for a method
 * @param classId - Class ID
 * @param methodName - Method name
 * @returns Array of ParameterInfo for the method's parameters
 */
export function getParameterInfo(classId: number, methodName: string): ParameterInfo[];

/**
 * Get modifiers for a field
 * @param classId - Class ID
 * @param fieldName - Field name
 * @returns Modifiers object or null if field not found
 */
export function getFieldModifiers(classId: number, fieldName: string): Modifiers | null;

/**
 * Get modifiers for a method
 * @param classId - Class ID
 * @param methodName - Method name
 * @returns Modifiers object or null if method not found
 */
export function getMethodModifiers(classId: number, methodName: string): Modifiers | null;

// ============================================================================
// Dynamic Class Creation (Phase 10)
// ============================================================================

/**
 * Field definition for dynamic class creation
 */
export interface FieldDefinition {
    name: string;
    type: string;
    initialValue?: any;
    isStatic?: boolean;
    isReadonly?: boolean;
}

/**
 * Method definition for dynamic class creation
 */
export interface MethodDefinition {
    name: string;
    implementation: Function;
    isStatic?: boolean;
    isAsync?: boolean;
}

/**
 * Subclass definition for createSubclass
 */
export interface SubclassDefinition {
    fields?: FieldDefinition[];
    methods?: MethodDefinition[];
    constructor?: (...args: any[]) => void;
}

/**
 * Create a subclass of an existing class
 * @param superclassId - Parent class ID
 * @param name - Name for the new class
 * @param definition - Fields, methods, and constructor for the subclass
 * @returns Class ID of the new subclass
 */
export function createSubclass(superclassId: number, name: string, definition: SubclassDefinition): number;

/**
 * Extend a class with additional fields
 * @param classId - Class ID to extend
 * @param fields - Array of field definitions to add
 * @returns New class ID with the additional fields
 */
export function extendWith(classId: number, fields: FieldDefinition[]): number;

/**
 * Define a new class from scratch
 * @param name - Class name
 * @param definition - Class definition
 * @returns Class ID of the new class
 */
export function defineClass(name: string, definition: SubclassDefinition): number;

/**
 * Add a method to an existing dynamic class
 * @param classId - Class ID
 * @param name - Method name
 * @param functionId - Function ID for the method implementation
 */
export function addMethod(classId: number, name: string, functionId: number): void;

/**
 * Set the constructor for a dynamic class
 * @param classId - Class ID
 * @param functionId - Function ID for the constructor implementation
 */
export function setConstructor(classId: number, functionId: number): void;

// ============================================================================
// Generic Type Metadata (Phase 13)
// ============================================================================

/**
 * Generic parameter information
 */
export interface GenericParameterInfo {
    /** Parameter name (e.g., "T") */
    readonly name: string;
    /** Position in type parameter list */
    readonly index: number;
    /** Type constraint (e.g., "extends Comparable") or null */
    readonly constraint: string | null;
}

/**
 * Generic origin information for monomorphized types
 */
export interface GenericOrigin {
    /** Original generic class name (e.g., "Box") */
    readonly name: string;
    /** Type parameter names (e.g., ["T"]) */
    readonly typeParameters: string[];
    /** Actual type arguments (e.g., ["number"]) */
    readonly typeArguments: string[];
}

/**
 * Get the generic origin of a monomorphized class
 * @param classId - Class ID of a monomorphized class (e.g., Box_number)
 * @returns Original generic class name (e.g., "Box") or null if not a generic instance
 */
export function getGenericOrigin(classId: number): string | null;

/**
 * Get type parameters of a generic class
 * @param classId - Class ID
 * @returns Array of GenericParameterInfo
 */
export function getTypeParameters(classId: number): GenericParameterInfo[];

/**
 * Get type arguments of a monomorphized class
 * @param classId - Class ID
 * @returns Array of type argument names
 */
export function getTypeArguments(classId: number): string[];

/**
 * Check if a class is a generic instance (monomorphized from a generic)
 * @param classId - Class ID
 * @returns true if class was created by monomorphization
 */
export function isGenericInstance(classId: number): boolean;

/**
 * Get the base generic class ID
 * @param genericName - Name of the generic class (e.g., "Box")
 * @returns Class ID or null if not found
 */
export function getGenericBase(genericName: string): number | null;

/**
 * Find all specializations of a generic class
 * @param genericName - Name of the generic class (e.g., "Box")
 * @returns Array of class IDs for all specializations (e.g., Box_number, Box_string)
 */
export function findSpecializations(genericName: string): number[];

// ============================================================================
// Runtime Type Creation (Phase 14)
// ============================================================================

/**
 * Create a new ClassBuilder for incremental class construction
 * @param name - Name for the new class
 * @returns Builder ID for use with other ClassBuilder methods
 */
export function newClassBuilder(name: string): number;

/**
 * Set the parent class for a ClassBuilder
 * @param builderId - Builder ID from newClassBuilder
 * @param parentClassId - Parent class ID
 */
export function builderSetParent(builderId: number, parentClassId: number): void;

/**
 * Add a field to a ClassBuilder
 * @param builderId - Builder ID
 * @param name - Field name
 * @param typeName - Type name string
 * @param isReadonly - Whether the field is readonly
 * @param isStatic - Whether the field is static
 */
export function builderAddField(builderId: number, name: string, typeName: string, isReadonly: boolean, isStatic: boolean): void;

/**
 * Add a method to a ClassBuilder
 * @param builderId - Builder ID
 * @param name - Method name
 * @param functionId - Function ID for the method implementation
 * @param isStatic - Whether the method is static
 * @param isAsync - Whether the method is async
 */
export function builderAddMethod(builderId: number, name: string, functionId: number, isStatic: boolean, isAsync: boolean): void;

/**
 * Set the constructor for a ClassBuilder
 * @param builderId - Builder ID
 * @param functionId - Function ID for the constructor
 */
export function builderSetConstructor(builderId: number, functionId: number): void;

/**
 * Add an interface to a ClassBuilder
 * @param builderId - Builder ID
 * @param interfaceName - Interface name
 */
export function builderAddInterface(builderId: number, interfaceName: string): void;

/**
 * Build the class from a ClassBuilder
 * @param builderId - Builder ID
 * @returns Class ID of the newly created class
 */
export function builderBuild(builderId: number): number;

/**
 * Create a function from bytecode
 * @param name - Function name
 * @param paramCount - Number of parameters
 * @param bytecode - Array of bytecode instructions
 * @returns Function ID
 */
export function createFunction(name: string, paramCount: number, bytecode: number[]): number;

/**
 * Create an async function from bytecode
 * @param name - Function name
 * @param paramCount - Number of parameters
 * @param bytecode - Array of bytecode instructions
 * @returns Function ID
 */
export function createAsyncFunction(name: string, paramCount: number, bytecode: number[]): number;

/**
 * Create a closure with captured variables
 * @param functionId - Base function ID
 * @param captures - Array of captured values
 * @returns Closure ID
 */
export function createClosure(functionId: number, captures: any[]): number;

/**
 * Specialize a generic class with type arguments
 * @param genericName - Name of the generic class
 * @param typeArgs - Array of type argument names
 * @returns Class ID of the specialized class
 */
export function specialize(genericName: string, typeArgs: string[]): number;

// ============================================================================
// Method Wrapper Builder (Phase 14 - High-level API for Decorators)
// ============================================================================

/**
 * Wrapper hooks for method decoration
 * All hooks are optional - only provide the ones you need
 */
export interface WrapperHooks<F extends Function> {
    /** Called before the original method with its arguments */
    before?: (args: any[]) => void;
    /** Called after the original method with its result */
    after?: (result: any) => void;
    /** Called instead of the original - receives method and args, must call method */
    around?: (method: F, args: any[]) => any;
    /** Called if the original method throws an error */
    onError?: (error: any) => any;
}

/**
 * Create a wrapper function around a method (preferred API for decorators)
 *
 * This is a high-level API that internally uses DynamicFunctionBuilder.
 * Use this instead of BytecodeBuilder for method decorators.
 *
 * @param method - The original method to wrap
 * @param hooks - Wrapper hooks (before, after, around, onError)
 * @returns A new function that wraps the original
 *
 * @example
 * ```typescript
 * function Logged(): MethodDecorator<Function> {
 *     return (method: Function): Function => {
 *         return Reflect.createWrapper(method, {
 *             before: (args) => logger.info("Calling with", args),
 *             after: (result) => logger.info("Returned", result)
 *         });
 *     };
 * }
 * ```
 */
export function createWrapper<F extends Function>(method: F, hooks: WrapperHooks<F>): F;

/**
 * Create a simple method wrapper where wrapper controls execution
 *
 * @param method - The original method
 * @param wrapper - Wrapper function that receives (method, ...args) and controls execution
 * @returns A new function that delegates to the wrapper
 *
 * @example
 * ```typescript
 * function Cached(): MethodDecorator<Function> {
 *     const cache = new Map();
 *     return (method: Function): Function => {
 *         return Reflect.createMethodWrapper(method, (fn, ...args) => {
 *             const key = JSON.stringify(args);
 *             if (cache.has(key)) return cache.get(key);
 *             const result = fn(...args);
 *             cache.set(key, result);
 *             return result;
 *         });
 *     };
 * }
 * ```
 */
export function createMethodWrapper<F extends Function>(method: F, wrapper: (method: F, ...args: any[]) => any): F;

// ============================================================================
// Bytecode Builder (Phase 15 - Low-level API)
// ============================================================================

/**
 * Create a new BytecodeBuilder
 * @param name - Function name
 * @param paramCount - Number of parameters
 * @returns Builder ID
 */
export function newBytecodeBuilder(name: string, paramCount: number): number;

/**
 * Emit a bytecode instruction
 * @param builderId - Builder ID
 * @param opcode - Opcode number
 * @param operands - Operand values
 */
export function bcEmit(builderId: number, opcode: number, ...operands: number[]): void;

/**
 * Push a value onto the stack
 * @param builderId - Builder ID
 * @param value - Value to push
 */
export function bcEmitPush(builderId: number, value: any): void;

/**
 * Define a label for jumps
 * @param builderId - Builder ID
 * @returns Label ID
 */
export function bcDefineLabel(builderId: number): number;

/**
 * Mark the current position with a label
 * @param builderId - Builder ID
 * @param labelId - Label ID from bcDefineLabel
 */
export function bcMarkLabel(builderId: number, labelId: number): void;

/**
 * Emit a jump to a label
 * @param builderId - Builder ID
 * @param labelId - Label ID
 */
export function bcEmitJump(builderId: number, labelId: number): void;

/**
 * Emit a conditional jump
 * @param builderId - Builder ID
 * @param labelId - Label ID
 */
export function bcEmitJumpIf(builderId: number, labelId: number): void;

/**
 * Declare a local variable
 * @param builderId - Builder ID
 * @param typeName - Type name
 * @returns Local index
 */
export function bcDeclareLocal(builderId: number, typeName: string): number;

/**
 * Load a local variable
 * @param builderId - Builder ID
 * @param localIndex - Local index
 */
export function bcEmitLoadLocal(builderId: number, localIndex: number): void;

/**
 * Store to a local variable
 * @param builderId - Builder ID
 * @param localIndex - Local index
 */
export function bcEmitStoreLocal(builderId: number, localIndex: number): void;

/**
 * Emit a function call
 * @param builderId - Builder ID
 * @param functionId - Function ID to call
 * @param argCount - Number of arguments
 */
export function bcEmitCall(builderId: number, functionId: number, argCount: number): void;

/**
 * Emit a return instruction
 * @param builderId - Builder ID
 */
export function bcEmitReturn(builderId: number): void;

/**
 * Validate the bytecode
 * @param builderId - Builder ID
 * @returns Array of error messages (empty if valid)
 */
export function bcValidate(builderId: number): string[];

/**
 * Build the function from bytecode
 * @param builderId - Builder ID
 * @returns Function ID
 */
export function bcBuild(builderId: number): number;

// ============================================================================
// Reflection Permissions (Phase 16)
// ============================================================================

/**
 * Reflection permission flags (can be combined with |)
 */
export const enum ReflectionPermission {
    NONE = 0,
    READ_PUBLIC = 1,
    READ_PRIVATE = 2,
    WRITE_PUBLIC = 4,
    WRITE_PRIVATE = 8,
    INVOKE_PUBLIC = 16,
    INVOKE_PRIVATE = 32,
    CREATE_TYPES = 64,
    GENERATE_BYTECODE = 128,
    ALL = 255,
}

/**
 * Set permissions on an object or class
 * @param target - Target object or class ID
 * @param permissions - Permission flags
 */
export function setPermissions(target: any, permissions: number): void;

/**
 * Get permissions for an object or class
 * @param target - Target object or class ID
 * @returns Permission flags
 */
export function getPermissions(target: any): number;

/**
 * Check if a specific permission is granted
 * @param target - Target object or class ID
 * @param permission - Permission flag to check
 * @returns true if permission is granted
 */
export function hasPermission(target: any, permission: number): boolean;

/**
 * Clear all permissions on an object
 * @param target - Target object or class ID
 */
export function clearPermissions(target: any): void;

/**
 * Set class-level permissions
 * @param classId - Class ID
 * @param permissions - Permission flags
 */
export function setClassPermissions(classId: number, permissions: number): void;

/**
 * Get class-level permissions
 * @param classId - Class ID
 * @returns Permission flags
 */
export function getClassPermissions(classId: number): number;

/**
 * Clear class-level permissions
 * @param classId - Class ID
 */
export function clearClassPermissions(classId: number): void;

/**
 * Set module-level permissions
 * @param moduleName - Module name
 * @param permissions - Permission flags
 */
export function setModulePermissions(moduleName: string, permissions: number): void;

/**
 * Get module-level permissions
 * @param moduleName - Module name
 * @returns Permission flags
 */
export function getModulePermissions(moduleName: string): number;

/**
 * Clear module-level permissions
 * @param moduleName - Module name
 */
export function clearModulePermissions(moduleName: string): void;

/**
 * Set global default permissions
 * @param permissions - Permission flags
 */
export function setGlobalPermissions(permissions: number): void;

/**
 * Get global default permissions
 * @returns Permission flags
 */
export function getGlobalPermissions(): number;

/**
 * Seal permissions on a target (make immutable)
 * @param target - Target object or class ID
 */
export function sealPermissions(target: any): void;

/**
 * Check if permissions are sealed
 * @param target - Target object or class ID
 * @returns true if permissions are sealed
 */
export function isPermissionsSealed(target: any): boolean;

// ============================================================================
// Dynamic Module System (Phase 17)
// ============================================================================

/**
 * Create a new dynamic module
 * @param name - Module name
 * @returns Module ID
 */
export function createModule(name: string): number;

/**
 * Add a function to a dynamic module
 * @param moduleId - Module ID
 * @param functionId - Function ID to add
 */
export function moduleAddFunction(moduleId: number, functionId: number): void;

/**
 * Add a class to a dynamic module
 * @param moduleId - Module ID
 * @param classId - Class ID to add
 * @param name - Export name for the class
 */
export function moduleAddClass(moduleId: number, classId: number, name: string): void;

/**
 * Add a global variable to a dynamic module
 * @param moduleId - Module ID
 * @param name - Variable name
 * @param value - Initial value
 */
export function moduleAddGlobal(moduleId: number, name: string, value: any): void;

/**
 * Seal a module (finalize for execution)
 * @param moduleId - Module ID
 */
export function moduleSeal(moduleId: number): void;

/**
 * Link module imports
 * @param moduleId - Module ID
 * @param imports - Import specifications
 */
export function moduleLink(moduleId: number, imports: Map<string, number>): void;

/**
 * Get module info by ID
 * @param moduleId - Module ID
 * @returns Module info object or null
 */
export function getModule(moduleId: number): { name: string; isSealed: boolean } | null;

/**
 * Get module by name
 * @param name - Module name
 * @returns Module ID or null
 */
export function getModuleByName(name: string): number | null;

// ============================================================================
// Dynamic Execution (Phase 17)
// ============================================================================

/**
 * Execute a function dynamically
 * @param functionId - Function ID to execute
 * @param args - Arguments
 * @returns Function result
 */
export function execute(functionId: number, ...args: any[]): any;

/**
 * Spawn a function as a Task
 * @param functionId - Function ID to spawn
 * @param args - Arguments
 * @returns Task handle
 */
export function spawn(functionId: number, ...args: any[]): any;

/**
 * Execute raw bytecode
 * @param bytecode - Bytecode array
 * @returns Execution result
 */
export function eval_(bytecode: number[]): any;

// ============================================================================
// Bootstrap Context (Phase 17)
// ============================================================================

/**
 * Initialize the bootstrap context
 * @returns true if bootstrap succeeded
 */
export function bootstrap(): boolean;

/**
 * Check if bootstrap context is initialized
 * @returns true if bootstrapped
 */
export function isBootstrapped(): boolean;

/**
 * Get the core Object class ID
 * @returns Class ID for Object
 */
export function getObjectClass(): number;

/**
 * Get the core Array class ID
 * @returns Class ID for Array
 */
export function getArrayClass(): number;

/**
 * Get the core String class ID
 * @returns Class ID for String
 */
export function getStringClass(): number;

/**
 * Get the core Task class ID
 * @returns Class ID for Task
 */
export function getTaskClass(): number;

/**
 * Print a message (for dynamic code)
 * @param message - Message to print
 */
export function dynamicPrint(message: string): void;

/**
 * Create a dynamic array
 * @param elements - Array elements
 * @returns Array reference
 */
export function createDynamicArray(elements: any[]): any[];

/**
 * Create a dynamic string
 * @param value - String value
 * @returns String reference
 */
export function createDynamicString(value: string): string;
