// Crypto - Standard crypto module
// Usage: import crypto from "std:crypto";

class Crypto {
    // ── Hashing ──

    hash(algorithm: string, data: string): string {
        return __NATIVE_CALL<string>("crypto.hash", algorithm, data);
    }

    hashBytes(algorithm: string, data: Buffer): Buffer {
        return __NATIVE_CALL<Buffer>("crypto.hashBytes", algorithm, data);
    }

    // ── HMAC ──

    hmac(algorithm: string, key: string, data: string): string {
        return __NATIVE_CALL<string>("crypto.hmac", algorithm, key, data);
    }

    hmacBytes(algorithm: string, key: Buffer, data: Buffer): Buffer {
        return __NATIVE_CALL<Buffer>("crypto.hmacBytes", algorithm, key, data);
    }

    // ── Random ──

    randomBytes(size: number): Buffer {
        return __NATIVE_CALL<Buffer>("crypto.randomBytes", size);
    }

    randomInt(min: number, max: number): number {
        return __NATIVE_CALL<number>("crypto.randomInt", min, max);
    }

    randomUUID(): string {
        return __NATIVE_CALL<string>("crypto.randomUUID");
    }

    // ── Encoding ──

    toHex(data: Buffer): string {
        return __NATIVE_CALL<string>("crypto.toHex", data);
    }

    fromHex(hex: string): Buffer {
        return __NATIVE_CALL<Buffer>("crypto.fromHex", hex);
    }

    toBase64(data: Buffer): string {
        return __NATIVE_CALL<string>("crypto.toBase64", data);
    }

    fromBase64(b64: string): Buffer {
        return __NATIVE_CALL<Buffer>("crypto.fromBase64", b64);
    }

    // ── Comparison ──

    timingSafeEqual(a: Buffer, b: Buffer): boolean {
        return __NATIVE_CALL<boolean>("crypto.timingSafeEqual", a, b);
    }

    // ── Encryption ──

    encrypt(key: Buffer, plaintext: Buffer): Buffer {
        return __NATIVE_CALL<Buffer>("crypto.encrypt", key, plaintext);
    }

    decrypt(key: Buffer, ciphertext: Buffer): Buffer {
        return __NATIVE_CALL<Buffer>("crypto.decrypt", key, ciphertext);
    }

    // ── Key Generation ──

    generateKey(bits: number): Buffer {
        return __NATIVE_CALL<Buffer>("crypto.generateKey", bits);
    }

    // ── Signing ──

    sign(algorithm: string, privateKey: Buffer, data: Buffer): Buffer {
        return __NATIVE_CALL<Buffer>("crypto.sign", algorithm, privateKey, data);
    }

    verify(algorithm: string, publicKey: Buffer, data: Buffer, signature: Buffer): boolean {
        return __NATIVE_CALL<boolean>("crypto.verify", algorithm, publicKey, data, signature);
    }

    generateKeyPair(algorithm: string): string[] {
        return __NATIVE_CALL<string[]>("crypto.generateKeyPair", algorithm);
    }

    // ── Key Derivation ──

    hkdf(hash: string, ikm: Buffer, salt: Buffer, info: Buffer, length: number): Buffer {
        return __NATIVE_CALL<Buffer>("crypto.hkdf", hash, ikm, salt, info, length);
    }

    pbkdf2(password: string, salt: Buffer, iterations: number, length: number, hash: string): Buffer {
        return __NATIVE_CALL<Buffer>("crypto.pbkdf2", password, salt, iterations, length, hash);
    }
}

const crypto = new Crypto();
export default crypto;
