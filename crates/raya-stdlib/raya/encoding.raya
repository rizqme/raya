// Encoding - Standard encoding module (CSV, XML, Base32)
// Usage: import encoding from "std:encoding";
// Usage: import { CsvTable, XmlNode, Csv, Xml, Base32 } from "std:encoding";

// ── CSV Table (handle-based) ──

class CsvTable {
    _handle: number;

    constructor(handle: number) {
        this._handle = handle;
    }

    headers(): string[] {
        return __NATIVE_CALL<string[]>("encoding.csvTableHeaders", this._handle);
    }

    rows(): string[] {
        return __NATIVE_CALL<string[]>("encoding.csvTableRows", this._handle);
    }

    row(index: number): string[] {
        return __NATIVE_CALL<string[]>("encoding.csvTableRow", this._handle, index);
    }

    column(name: string): string[] {
        return __NATIVE_CALL<string[]>("encoding.csvTableColumn", this._handle, name);
    }

    rowCount(): number {
        return __NATIVE_CALL<number>("encoding.csvTableRowCount", this._handle);
    }

    release(): void {
        __NATIVE_CALL("encoding.csvTableRelease", this._handle);
    }

    stringify(): string {
        return __NATIVE_CALL<string>("encoding.csvStringify", this._handle);
    }

    stringifyWithHeaders(): string {
        return __NATIVE_CALL<string>("encoding.csvStringifyHeaders", this._handle);
    }
}

// ── XML Node (handle-based) ──

class XmlNode {
    _handle: number;

    constructor(handle: number) {
        this._handle = handle;
    }

    tag(): string {
        return __NATIVE_CALL<string>("encoding.xmlTag", this._handle);
    }

    text(): string {
        return __NATIVE_CALL<string>("encoding.xmlText", this._handle);
    }

    attr(name: string): string {
        return __NATIVE_CALL<string>("encoding.xmlAttr", this._handle, name);
    }

    attrs(): string[] {
        return __NATIVE_CALL<string[]>("encoding.xmlAttrs", this._handle);
    }

    children(): XmlNode[] {
        const handles: number[] = __NATIVE_CALL<number[]>("encoding.xmlChildren", this._handle);
        const nodes: XmlNode[] = [];
        let i = 0;
        while (i < handles.length) {
            nodes.push(new XmlNode(handles[i]));
            i = i + 1;
        }
        return nodes;
    }

    child(tagName: string): XmlNode {
        const handle: number = __NATIVE_CALL<number>("encoding.xmlChild", this._handle, tagName);
        return new XmlNode(handle);
    }

    childrenByTag(tagName: string): XmlNode[] {
        const handles: number[] = __NATIVE_CALL<number[]>("encoding.xmlChildrenByTag", this._handle, tagName);
        const nodes: XmlNode[] = [];
        let i = 0;
        while (i < handles.length) {
            nodes.push(new XmlNode(handles[i]));
            i = i + 1;
        }
        return nodes;
    }

    stringify(): string {
        return __NATIVE_CALL<string>("encoding.xmlStringify", this._handle);
    }

    release(): void {
        __NATIVE_CALL("encoding.xmlRelease", this._handle);
    }
}

// ── CSV Utilities ──

class Csv {
    parse(input: string): CsvTable {
        const handle: number = __NATIVE_CALL<number>("encoding.csvParse", input);
        return new CsvTable(handle);
    }

    parseWithHeaders(input: string): CsvTable {
        const handle: number = __NATIVE_CALL<number>("encoding.csvParseHeaders", input);
        return new CsvTable(handle);
    }
}

// ── XML Utilities ──

class Xml {
    parse(input: string): XmlNode {
        const handle: number = __NATIVE_CALL<number>("encoding.xmlParse", input);
        return new XmlNode(handle);
    }
}

// ── Base32 Utilities ──

class Base32 {
    encode(data: Buffer): string {
        return __NATIVE_CALL<string>("encoding.base32Encode", data);
    }

    decode(input: string): Buffer {
        return __NATIVE_CALL<Buffer>("encoding.base32Decode", input);
    }

    hexEncode(data: Buffer): string {
        return __NATIVE_CALL<string>("encoding.base32HexEncode", data);
    }

    hexDecode(input: string): Buffer {
        return __NATIVE_CALL<Buffer>("encoding.base32HexDecode", input);
    }
}

// ── JSON Value (handle-based) ──

class JsonValue {
    _handle: number;

    constructor(handle: number) {
        this._handle = handle;
    }

    get(key: string): JsonValue {
        const h: number = __NATIVE_CALL<number>("encoding.jsonGet", this._handle, key);
        return new JsonValue(h);
    }

    at(index: number): JsonValue {
        const h: number = __NATIVE_CALL<number>("encoding.jsonAt", this._handle, index);
        return new JsonValue(h);
    }

    string(): string {
        return __NATIVE_CALL<string>("encoding.jsonString", this._handle);
    }

    number(): number {
        return __NATIVE_CALL<number>("encoding.jsonNumber", this._handle);
    }

    bool(): boolean {
        return __NATIVE_CALL<boolean>("encoding.jsonBool", this._handle);
    }

    isNull(): boolean {
        return __NATIVE_CALL<boolean>("encoding.jsonIsNull", this._handle);
    }

    type(): string {
        return __NATIVE_CALL<string>("encoding.jsonType", this._handle);
    }

    keys(): string[] {
        return __NATIVE_CALL<string[]>("encoding.jsonKeys", this._handle);
    }

    length(): number {
        return __NATIVE_CALL<number>("encoding.jsonLength", this._handle);
    }

    set(key: string, value: JsonValue): void {
        __NATIVE_CALL("encoding.jsonSet", this._handle, key, value._handle);
    }

    push(value: JsonValue): void {
        __NATIVE_CALL("encoding.jsonPush", this._handle, value._handle);
    }

    stringify(): string {
        return __NATIVE_CALL<string>("encoding.jsonStringify", this._handle);
    }

    stringifyPretty(): string {
        return __NATIVE_CALL<string>("encoding.jsonStringifyPretty", this._handle);
    }

    release(): void {
        __NATIVE_CALL("encoding.jsonRelease", this._handle);
    }
}

// ── JSON Utilities ──

class Json {
    parse(input: string): JsonValue {
        const h: number = __NATIVE_CALL<number>("encoding.jsonParse", input);
        return new JsonValue(h);
    }

    stringify(value: JsonValue): string {
        return __NATIVE_CALL<string>("encoding.jsonStringify", value._handle);
    }

    stringifyPretty(value: JsonValue): string {
        return __NATIVE_CALL<string>("encoding.jsonStringifyPretty", value._handle);
    }

    newObject(): JsonValue {
        const h: number = __NATIVE_CALL<number>("encoding.jsonNewObject");
        return new JsonValue(h);
    }

    newArray(): JsonValue {
        const h: number = __NATIVE_CALL<number>("encoding.jsonNewArray");
        return new JsonValue(h);
    }

    fromString(s: string): JsonValue {
        const h: number = __NATIVE_CALL<number>("encoding.jsonFromString", s);
        return new JsonValue(h);
    }

    fromNumber(n: number): JsonValue {
        const h: number = __NATIVE_CALL<number>("encoding.jsonFromNumber", n);
        return new JsonValue(h);
    }

    fromBool(b: boolean): JsonValue {
        const h: number = __NATIVE_CALL<number>("encoding.jsonFromBool", b);
        return new JsonValue(h);
    }

    null(): JsonValue {
        const h: number = __NATIVE_CALL<number>("encoding.jsonNull");
        return new JsonValue(h);
    }
}

// ── TOML Utilities ──

class Toml {
    parse(input: string): JsonValue {
        const h: number = __NATIVE_CALL<number>("encoding.tomlParse", input);
        return new JsonValue(h);
    }

    stringify(value: JsonValue): string {
        return __NATIVE_CALL<string>("encoding.tomlStringify", value._handle);
    }
}

// ── Encoding Facade ──

class Encoding {
    csv: Csv;
    xml: Xml;
    base32: Base32;
    json: Json;
    toml: Toml;

    constructor() {
        this.csv = new Csv();
        this.xml = new Xml();
        this.base32 = new Base32();
        this.json = new Json();
        this.toml = new Toml();
    }
}

const encoding = new Encoding();
export { CsvTable, XmlNode, JsonValue, Csv, Xml, Base32, Json, Toml };
export default encoding;
